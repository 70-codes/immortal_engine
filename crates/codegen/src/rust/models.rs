//! Rust model code generation
//!
//! This module provides utilities for generating Rust model/struct code
//! from entity nodes in the project graph.

use imortal_ir::Node;
use imortal_core::DataType;

/// Generate a Rust model struct from an entity node
pub fn generate_model(node: &Node) -> String {
    let mut output = String::new();

    // Add module documentation
    output.push_str(&format!(
        "//! {} model\n//!\n//! Generated by Immortal Engine\n\n",
        node.name
    ));

    // Add imports
    output.push_str("use serde::{Deserialize, Serialize};\n");
    if has_uuid_field(node) {
        output.push_str("use uuid::Uuid;\n");
    }
    if has_datetime_field(node) {
        output.push_str("use chrono::{DateTime, Utc};\n");
    }
    output.push('\n');

    // Add struct definition
    output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    output.push_str(&format!("pub struct {} {{\n", node.name));

    for field in &node.fields {
        let rust_type = field.rust_type();
        let field_name = to_snake_case(&field.name);

        // Add field documentation if available
        if let Some(desc) = &field.description {
            output.push_str(&format!("    /// {}\n", desc));
        }

        output.push_str(&format!("    pub {}: {},\n", field_name, rust_type));
    }

    output.push_str("}\n");

    output
}

/// Generate impl block with common methods
pub fn generate_model_impl(node: &Node) -> String {
    let mut output = String::new();

    output.push_str(&format!("\nimpl {} {{\n", node.name));

    // Generate new() constructor
    output.push_str("    /// Create a new instance\n");
    output.push_str("    pub fn new() -> Self {\n");
    output.push_str("        Self::default()\n");
    output.push_str("    }\n");

    output.push_str("}\n");

    // Generate Default impl
    output.push_str(&format!("\nimpl Default for {} {{\n", node.name));
    output.push_str("    fn default() -> Self {\n");
    output.push_str("        Self {\n");

    for field in &node.fields {
        let field_name = to_snake_case(&field.name);
        let default_value = get_default_value(&field.data_type, field.required);
        output.push_str(&format!("            {}: {},\n", field_name, default_value));
    }

    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    output
}

/// Check if any field uses UUID type
fn has_uuid_field(node: &Node) -> bool {
    node.fields.iter().any(|f| matches!(f.data_type, DataType::Uuid))
}

/// Check if any field uses DateTime type
fn has_datetime_field(node: &Node) -> bool {
    node.fields.iter().any(|f| matches!(f.data_type, DataType::DateTime | DataType::Date | DataType::Time))
}

/// Get default value for a data type
fn get_default_value(data_type: &DataType, required: bool) -> String {
    if !required {
        return "None".to_string();
    }

    match data_type {
        DataType::String | DataType::Text => "String::new()".to_string(),
        DataType::Int32 | DataType::Int64 => "0".to_string(),
        DataType::Float32 | DataType::Float64 => "0.0".to_string(),
        DataType::Bool => "false".to_string(),
        DataType::Uuid => "Uuid::new_v4()".to_string(),
        DataType::DateTime => "Utc::now()".to_string(),
        DataType::Bytes => "Vec::new()".to_string(),
        DataType::Json => "serde_json::Value::Null".to_string(),
        DataType::Array(_) => "Vec::new()".to_string(),
        DataType::Optional(_) => "None".to_string(),
        _ => "Default::default()".to_string(),
    }
}

/// Convert string to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut prev_is_upper = false;

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 && !prev_is_upper {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
            prev_is_upper = true;
        } else if c == '-' || c == ' ' {
            result.push('_');
            prev_is_upper = false;
        } else {
            result.push(c);
            prev_is_upper = false;
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("userId"), "user_id");
        assert_eq!(to_snake_case("UserName"), "user_name");
        assert_eq!(to_snake_case("id"), "id");
    }

    #[test]
    fn test_get_default_value() {
        assert_eq!(get_default_value(&DataType::String, true), "String::new()");
        assert_eq!(get_default_value(&DataType::Int32, true), "0");
        assert_eq!(get_default_value(&DataType::Bool, true), "false");
        assert_eq!(get_default_value(&DataType::String, false), "None");
    }
}
