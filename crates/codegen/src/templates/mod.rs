//! Code generation templates
//!
//! This module provides template-based code generation utilities.
//! Templates can be used to generate boilerplate code for various
//! components and patterns.

use std::collections::HashMap;

/// A simple template engine for code generation
pub struct Template {
    /// The template content with placeholders
    content: String,
}

impl Template {
    /// Create a new template from a string
    pub fn new(content: impl Into<String>) -> Self {
        Self {
            content: content.into(),
        }
    }

    /// Render the template with the given variables
    pub fn render(&self, vars: &HashMap<String, String>) -> String {
        let mut result = self.content.clone();

        for (key, value) in vars {
            let placeholder = format!("{{{{{}}}}}", key);
            result = result.replace(&placeholder, value);
        }

        result
    }

    /// Render with a single variable
    pub fn render_one(&self, key: &str, value: &str) -> String {
        let mut vars = HashMap::new();
        vars.insert(key.to_string(), value.to_string());
        self.render(&vars)
    }
}

/// Built-in templates for common code patterns
pub mod builtins {
    use super::*;

    /// Rust struct template
    pub fn rust_struct() -> Template {
        Template::new(r#"#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct {{name}} {
{{fields}}
}
"#)
    }

    /// Rust impl block template
    pub fn rust_impl() -> Template {
        Template::new(r#"impl {{name}} {
{{methods}}
}
"#)
    }

    /// Rust module file template
    pub fn rust_module() -> Template {
        Template::new(r#"//! {{description}}

{{imports}}

{{content}}
"#)
    }

    /// Cargo.toml template
    pub fn cargo_toml() -> Template {
        Template::new(r#"[package]
name = "{{name}}"
version = "{{version}}"
edition = "2021"

[dependencies]
{{dependencies}}
"#)
    }

    /// Rust main.rs template
    pub fn rust_main() -> Template {
        Template::new(r#"//! {{name}} - Generated by Immortal Engine

{{modules}}

#[tokio::main]
async fn main() {
    {{setup}}

    {{main_body}}
}
"#)
    }

    /// Axum handler template
    pub fn axum_handler() -> Template {
        Template::new(r#"pub async fn {{name}}(
{{params}}
) -> impl axum::response::IntoResponse {
    {{body}}
}
"#)
    }

    /// SQL migration template
    pub fn sql_migration() -> Template {
        Template::new(r#"-- Migration: {{name}}
-- Created at: {{timestamp}}

-- Up
{{up_sql}}

-- Down
{{down_sql}}
"#)
    }
}

/// Template builder for constructing complex templates
pub struct TemplateBuilder {
    parts: Vec<String>,
}

impl TemplateBuilder {
    pub fn new() -> Self {
        Self { parts: Vec::new() }
    }

    pub fn line(mut self, content: impl Into<String>) -> Self {
        self.parts.push(content.into());
        self
    }

    pub fn newline(mut self) -> Self {
        self.parts.push(String::new());
        self
    }

    pub fn indent(mut self, level: usize, content: impl Into<String>) -> Self {
        let indent = "    ".repeat(level);
        self.parts.push(format!("{}{}", indent, content.into()));
        self
    }

    pub fn build(self) -> Template {
        Template::new(self.parts.join("\n"))
    }
}

impl Default for TemplateBuilder {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_template_render() {
        let template = Template::new("Hello, {{name}}!");
        let mut vars = HashMap::new();
        vars.insert("name".to_string(), "World".to_string());

        assert_eq!(template.render(&vars), "Hello, World!");
    }

    #[test]
    fn test_template_render_multiple() {
        let template = Template::new("{{greeting}}, {{name}}!");
        let mut vars = HashMap::new();
        vars.insert("greeting".to_string(), "Hello".to_string());
        vars.insert("name".to_string(), "World".to_string());

        assert_eq!(template.render(&vars), "Hello, World!");
    }

    #[test]
    fn test_template_builder() {
        let template = TemplateBuilder::new()
            .line("fn main() {")
            .indent(1, "println!(\"Hello\");")
            .line("}")
            .build();

        let expected = "fn main() {\n    println!(\"Hello\");\n}";
        assert_eq!(template.content, expected);
    }

    #[test]
    fn test_builtin_struct_template() {
        let template = builtins::rust_struct();
        let mut vars = HashMap::new();
        vars.insert("name".to_string(), "User".to_string());
        vars.insert("fields".to_string(), "    pub id: i32,".to_string());

        let result = template.render(&vars);
        assert!(result.contains("pub struct User"));
        assert!(result.contains("pub id: i32"));
    }
}
